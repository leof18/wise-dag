// NEO4JS SCRIPT COLLECTION

// Step 1: For all concepts, inherit causal relationships from descendant concepts
MATCH (ancestor:Concept)-[:SUBSUMES*]->(descendant:Concept)-[r:CAUSES]->(effect:Concept)
MERGE (ancestor)-[new:CAUSES]->(effect)

// OPTIONAL: Creates lots of cycles, discuss in meeting
// Step 2: Establish causal relationships between ancestor nodes based on descendant relationships
MATCH (ancestor1:Concept)-[:SUBSUMES*]->(descendant1:Concept)-[:CAUSES]->(descendant2:Concept)<-[:SUBSUMES*]-(ancestor2:Concept)
WHERE ancestor1 <> ancestor2
MERGE (ancestor1)-[:CAUSES]->(ancestor2)

// POTENTIALLY USEFUL TO PREVENT BEING ABLE TO EXPAND NODES THAT ARE ALREADY FULLY EXPANDED (color code in UI?)
// Set is_leaf_node to false for all nodes initially
MATCH (node:Concept)
SET node.is_leaf_node = false;
// Set is_leaf_node to true for leaf nodes
MATCH (node:Concept)
WHERE NOT EXISTS { MATCH (node)-[:SUBSUMES]->(:Concept) }
SET node.is_leaf_node = true;


// MAIN SCRIPT TO QUERY DATABASE

// Get nodes, excluding expanded nodes
MATCH (iteration:Iteration {id: $selectedIteration.id})
MATCH (concept:Concept)-[:PART_OF]->(iteration)
WHERE NOT concept.name IN $selectedNodes.name
MATCH (exposure:Concept {name: $exposure.name})
MATCH (outcome:Concept {name: $outcome.name})

// Get children of expanded nodes
OPTIONAL MATCH (expanded:Concept)-[:SUBSUMES]->(child:Concept) 
WHERE expanded.name IN $selectedNodes.name

// Collect all nodes
WITH COLLECT(concept) + COLLECT(DISTINCT child) AS initialNodes, exposure, outcome

// Ensure exposure and outcome are only added if they are not already in concepts or children
WITH CASE 
        WHEN exposure IN initialNodes THEN initialNodes 
        ELSE initialNodes + [exposure]
    END AS nodesWithExposure,
    outcome
WITH CASE 
        WHEN outcome IN nodesWithExposure THEN nodesWithExposure 
        ELSE nodesWithExposure + [outcome] 
    END AS Nodes

// Match only relationships that exist between these Nodes
UNWIND Nodes AS Node
OPTIONAL MATCH (Node)-[causal:CAUSES]->(otherNode)
WHERE otherNode IN Nodes

RETURN 
    COLLECT(DISTINCT Node) AS resultingNodes,
    COLLECT(DISTINCT causal) AS causalRelationships,

    // For Dagitty
    COLLECT(DISTINCT Node.name) AS allNodes,
    COLLECT(DISTINCT { from: Node.name, to: otherNode.name }) AS causalEdges;