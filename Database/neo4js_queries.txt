// NEO4JS SCRIPT COLLECTION

// Step 1: For all concepts, inherit causal relationships from descendant concepts
MATCH (ancestor:Concept)-[:SUBSUMES*]->(descendant:Concept)-[r:CAUSES]->(effect:Concept)
MERGE (ancestor)-[new:CAUSES]->(effect)

// OPTIONAL: Creates lots of cycles, discuss in meeting
// Step 2: Establish causal relationships between ancestor nodes based on descendant relationships
// MATCH (ancestor1:Concept)-[:SUBSUMES*]->(descendant1:Concept)-[:CAUSES]->(descendant2:Concept)<-[:SUBSUMES*]-(ancestor2:Concept)
// WHERE ancestor1 <> ancestor2
// MERGE (ancestor1)-[:CAUSES]->(ancestor2)

:param selectedIteration => {id: 0};
:param selectedNode => {name: "Social context"};

// Retrieve all nodes at the specified iteration level
MATCH (n:Concept)-[:PART_OF]->(i:Iteration)
WHERE i.id = $selectedIteration.id
WITH collect(n) AS selectedLevelNodes
UNWIND selectedLevelNodes AS n
OPTIONAL MATCH (n)-[r:CAUSES]->(m:Concept)
WHERE m IN selectedLevelNodes
RETURN n, r, m

// Expanding a single node
// Step 1: Match the selected node using the parameter
MATCH (iteration:Iteration {id: $selectedIteration.id})
MATCH (excludedNode:Concept {name: $selectedNode.name})
// Step 2: Select all concept nodes with a part_of relationship to the iteration node 0, except of the elected node
MATCH (concept:Concept)-[:PART_OF]->(iteration)
WHERE concept.name <> $selectedNode.name
WITH collect(concept) AS initialConcepts, excludedNode
// Step 3: Find the children of the excluded node and combine with initial nodes
MATCH (excludedNode)-[:SUBSUMES]->(child:Concept)
WITH initialConcepts, collect(child) AS children
WITH initialConcepts + children AS finalNodes
// Step 4: Match causal relationships
UNWIND finalNodes AS finalNode
OPTIONAL MATCH (finalNode)-[causal:CAUSES]->(relatedFinalNode:Concept)
WHERE relatedFinalNode IN finalNodes
RETURN finalNodes, causal

// Expanding multiple nodes at the same time
