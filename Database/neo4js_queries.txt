// NEO4JS SCRIPT COLLECTION

// Step 1: For all concepts, inherit causal relationships from descendant concepts
MATCH (ancestor:Concept)-[:SUBSUMES*]->(descendant:Concept)-[r:CAUSES]->(effect:Concept)
MERGE (ancestor)-[new:CAUSES]->(effect)

// OPTIONAL: Creates lots of cycles, discuss in meeting
// Step 2: Establish causal relationships between ancestor nodes based on descendant relationships
MATCH (ancestor1:Concept)-[:SUBSUMES*]->(descendant1:Concept)-[:CAUSES]->(descendant2:Concept)<-[:SUBSUMES*]-(ancestor2:Concept)
WHERE ancestor1 <> ancestor2
MERGE (ancestor1)-[:CAUSES]->(ancestor2)

// POTENTIALLY USEFUL TO PREVENT BEING ABLE TO EXPAND NODES THAT ARE ALREADY FULLY EXPANDED (color code in UI?)
// Set is_leaf_node to false for all nodes initially
MATCH (node:Concept)
SET node.is_leaf_node = false;
// Set is_leaf_node to true for leaf nodes
MATCH (node:Concept)
WHERE NOT EXISTS { MATCH (node)-[:SUBSUMES]->(:Concept) }
SET node.is_leaf_node = true;

:param selectedIteration => {id: 0};
:param selectedNode => {name: "Social context"};

// Retrieve all nodes at the specified iteration level
MATCH (n:Concept)-[:PART_OF]->(i:Iteration)
WHERE i.id = $selectedIteration.id
WITH collect(n) AS selectedLevelNodes
UNWIND selectedLevelNodes AS n
OPTIONAL MATCH (n)-[r:CAUSES]->(m:Concept)
WHERE m IN selectedLevelNodes
RETURN n, r, m


// Expanding nodes
:param selectedIteration => {id: 0};
:param selectedNodes => {name: ["Social context", "Substance", "Biological substance","Troponin"]};
:param selectedConfidence => {score: 0};
MATCH (iteration:Iteration {id: $selectedIteration.id})
MATCH (excludedNodes:Concept)
WHERE excludedNodes.name IN $selectedNodes.name
MATCH (concept:Concept)-[:PART_OF]->(iteration)
WITH collect(concept) AS initialConcepts, excludedNodes
MATCH (excludedNodes)-[:SUBSUMES]->(child:Concept)
WITH initialConcepts, collect(child) AS children
WITH initialConcepts + children AS combinedNodes
WITH [node IN combinedNodes WHERE NOT node.name IN $selectedNodes.name] AS finalNodes
UNWIND finalNodes AS finalNode
OPTIONAL MATCH (finalNode)-[causal:CAUSES]->(relatedFinalNode:Concept)
WHERE causal.confidence_mean > $selectedConfidence.score
RETURN COLLECT(DISTINCT(finalNode)) AS resultingNodes, causal;