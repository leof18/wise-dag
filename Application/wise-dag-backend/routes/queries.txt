:param selectedIteration => {id: 0};
:param selectedNodes => {name: [""]};
:param selectedConfidence => {score: 0};

MATCH (iteration:Iteration {id: $selectedIteration.id})
MATCH (excludedNodes:Concept)
WHERE excludedNodes.name IN $selectedNodes.name
MATCH (concept:Concept)-[:PART_OF]->(iteration)
WITH collect(concept) AS initialConcepts, excludedNodes
MATCH (excludedNodes)-[:SUBSUMES]->(child:Concept)
WITH initialConcepts, collect(child) AS children
WITH initialConcepts + children AS combinedNodes
WITH [node IN combinedNodes WHERE NOT node.name IN $selectedNodes.name] AS finalNodes
UNWIND finalNodes AS finalNode
OPTIONAL MATCH (finalNode)-[causal:CAUSES]->(relatedFinalNode:Concept)
WHERE causal.confidence_mean > $selectedConfidence.score
WITH finalNode, COLLECT(causal) AS causalRelationships
RETURN COLLECT(DISTINCT finalNode) AS resultingNodes, causalRelationships;


MATCH (n:Concept)-[:PART_OF]->(i:Iteration)
WHERE i.id = $selectedIteration.id
WITH collect(n) AS selectedLevelNodes
UNWIND selectedLevelNodes AS n
OPTIONAL MATCH (n)-[r:CAUSES]->(m:Concept)
WHERE m IN selectedLevelNodes
WITH DISTINCT n, r, m
RETURN n, r, m